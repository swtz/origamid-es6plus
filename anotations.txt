// ANOTAÇÕES | ORIGAMID - ES6+ | 05 EFEITOS NO DOM

// AULA 0506 | Event Bubble

// Call Stack: onde os eventos entram
// Memory: onde ficam as variáveis
// Web Api:
// Callback Queue & event loop: onde ficam os eventos assíncronos

// 1st row of <script.js>
  // Hoisting: variáveis são colocadas na memória
    // A const/let vai para a Temporary Dead Zone, ou seja, existe a variável,
    // mas não o seu valor
    // funções são colocadas na memória COM O CORPO
  // Execução do script
    // executa métodos e preenche as variáveis
    // HTMLElement.addEventListener('click', callbackFn);
      // um evento 'click' é atribuído ao elemento e a callbackFn
      // é disparada quando isso ocorrer. Porém, esse "encadeamento"
      // HTMLElement<-->click<-->callbackFn é colocado na Web Api, ou seja,
      // a UI do browser se comunica com essa Web Api, assim recebendo o evento
      // e disparando a função.
    // callbackFn disparada:
      // é colocada na Call Stack
      // o método segue sendo executado de maneira síncrona
      // html.addEventListener('click', handleOutside);
      // html<-->click<-->handleOutside

    // Web Api: HTMLElement<-->click<-->callbackFn | html<-->click<-->handleOutside

    // Bubble phase:
      // Definição: verifica se o elemento pai possui um evento de clique.
      // Não possui? Segue para o próximo.
      // Possui? Executa o evento, assim disparando a função handleOutside.
      // A fn handleOutside remove uma classe css. Isso se torna um bug, pois é
      // disparado um evento (e sua callbackFn) pelo javascript (não pelo user).
      // Isso é a fase de Bubble.
      // Vai até o 'window' que é o elemento máximo. Cadeia:
      // window<-->document<-->documentElement(html)<-->body<-->HTMLElement
  // Enquanto o site estiver ativo, a Web Api preserva o encadeamento (o conteúdo)
  // das variáveis e das funções permanecem na memória.
  